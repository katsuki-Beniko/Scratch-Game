<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scratch to Reveal</title>
    <link rel="stylesheet" href="./style.css">
    <style>
        /* Ensure touch actions like scrolling are disabled for the canvas */
        canvas {
            touch-action: none;
        }
    </style>
    <script type="module">
    import {
        HiddenImageSrc, CoverImageSrc, CongratsImageSrc, eraseTimeoutDuration, resetTimeoutDuration,
        CoverSizeWidth, CoverSizeHeight, threshold, coverPositionX, coverPositionY,
        congratulationSizeWidth, congratulationSizeHeight, congratulationPositionX, congratulationPositionY
    } from './getimage.js';

    document.addEventListener("DOMContentLoaded", function () {
        const canvasBackground = document.getElementById("backgroundCanvas");
        const ctxBackground = canvasBackground.getContext("2d", { willReadFrequently: true });

        const canvasCover = document.getElementById("coverCanvas");
        const ctxCover = canvasCover.getContext("2d", { willReadFrequently: true });

        const blueSquareImage = new Image();
        const coverImage = new Image();
        const congratsImage = new Image();

        let isDrawing = false;
        let eraseStarted = false;
        let eraseComplete = false;
        const container = document.getElementById("canvas-container");

        const containerWidth = container.offsetWidth;
        const containerHeight = container.offsetHeight;

        let eraseImageTimer;
        let resetGameTimer;

        // Get device pixel ratio and adjust canvas size accordingly
        const dpr = window.devicePixelRatio || 1;
        canvasBackground.width = containerWidth * dpr;
        canvasBackground.height = containerHeight * dpr;
        canvasCover.width = containerWidth * dpr;
        canvasCover.height = containerHeight * dpr;

        // Scale the context to match the device pixel ratio
        ctxBackground.scale(dpr, dpr);
        ctxCover.scale(dpr, dpr);

        // Load the cover image first
        function loadCoverImage() {
            coverImage.src = CoverImageSrc;
            coverImage.onload = () => {
                ctxCover.globalCompositeOperation = "source-over";
                ctxCover.drawImage(coverImage, coverPositionX, coverPositionY, CoverSizeWidth, CoverSizeHeight);
                loadHiddenImage();
            };
        }

        // Load the hidden image (background)
        function loadHiddenImage() {
            blueSquareImage.src = HiddenImageSrc;
            blueSquareImage.onload = () => {
                ctxBackground.drawImage(blueSquareImage, coverPositionX, coverPositionY, canvasBackground.width, canvasBackground.height);
            };
        }

        // Load the congratulations image
        function loadCongratsImage() {
            congratsImage.src = CongratsImageSrc;
            congratsImage.onload = () => {
                ctxCover.globalCompositeOperation = "source-over";
                ctxCover.clearRect(0, 0, canvasCover.width, canvasCover.height);
                ctxCover.drawImage(congratsImage, congratulationPositionX, congratulationPositionY, congratulationSizeWidth, congratulationSizeHeight);
            };
        }

        loadCoverImage();

        // Get position for touch and mouse events
        function getPosition(e) {
            const rect = canvasCover.getBoundingClientRect();
            const scaleX = canvasCover.width / rect.width;
            const scaleY = canvasCover.height / rect.height;

            if (e.touches) { // Mobile touch events
                const touch = e.touches[0]; // Get the first touch
                return {
                    x: (touch.clientX - rect.left) * scaleX,
                    y: (touch.clientY - rect.top) * scaleY
                };
            } else { // Mouse events
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
        }

        // Handle erasing (main function)
        function erase(e) {
            if (!isDrawing || eraseComplete) return;

            const { x, y } = getPosition(e);

            // Dynamically adjust erase radius for mobile (smaller radius on phones)
            const eraseRadius = window.innerWidth < 768 ? 10 : 20;  // 10px for phones, 20px for tablets/desktops

            ctxCover.globalCompositeOperation = "destination-out";
            ctxCover.beginPath();
            ctxCover.arc(x, y, eraseRadius, 0, Math.PI * 2);  // Erase area with dynamic radius
            ctxCover.fill();
            ctxCover.globalCompositeOperation = "source-over"; // Reset the composite mode

            checkErasedArea();
        }

        function checkErasedArea() {
            const imageData = ctxCover.getImageData(coverPositionX, coverPositionY, CoverSizeWidth, CoverSizeHeight);
            const totalPixels = imageData.width * imageData.height;
            let erasedPixels = 0;

            for (let i = 0; i < totalPixels * 4; i += 4) {
                if (imageData.data[i + 3] === 0) {
                    erasedPixels++;
                }
            }

            const erasedPercentage = erasedPixels / totalPixels;

            if (erasedPercentage > threshold) {
                ctxCover.clearRect(coverPositionX, coverPositionY, CoverSizeWidth, CoverSizeHeight);
                loadCongratsImage();
                startResetGameTimer();
            }
        }

        // Handle mouse and touch events
        function handleStart(e) {
            e.preventDefault();  // Prevent scrolling on touch
            if (e.touches && e.touches.length > 1) return; // Disable multi-touch for mobile
            startDrawing(e);
        }

        function startDrawing(e) {
            if (eraseComplete) return;
            isDrawing = true;
            eraseStarted = true;
            erase(e);  // Trigger the first erase action
            startEraseImageTimer();
        }

        function stopDrawing() {
            isDrawing = false;
            ctxCover.beginPath();  // Reset the drawing path
        }

        // Support both mouse and touch events
        function handleMove(e) {
            e.preventDefault();  // Prevent scrolling on touch
            if (isDrawing) {
                erase(e);  // Continuously erase while dragging or touching
            }
        }

        function handleEnd(e) {
            e.preventDefault();
            stopDrawing();
        }

        canvasCover.addEventListener("mousedown", handleStart);
        canvasCover.addEventListener("mousemove", handleMove);
        canvasCover.addEventListener("mouseup", handleEnd);

        canvasCover.addEventListener("touchstart", handleStart, { passive: false });
        canvasCover.addEventListener("touchmove", handleMove, { passive: false });
        canvasCover.addEventListener("touchend", handleEnd, { passive: false });

        // Erase timeout for inactivity
        function startEraseImageTimer() {
            clearTimeout(eraseImageTimer);
            if (eraseStarted) {
                eraseImageTimer = setTimeout(() => {
                    ctxCover.clearRect(coverPositionX, coverPositionY, CoverSizeWidth, CoverSizeHeight);
                    eraseComplete = true;
                    loadCongratsImage();
                    startResetGameTimer();
                }, eraseTimeoutDuration);
            }
        }

        // Reset the game after a timeout
        function startResetGameTimer() {
            clearTimeout(resetGameTimer);
            resetGameTimer = setTimeout(() => {
                // Reset game if needed
            }, resetTimeoutDuration);
        }
    });
    </script>
</head>
<body>
    <div id="canvas-container">
        <canvas id="backgroundCanvas"></canvas>
        <canvas id="coverCanvas"></canvas>
    </div>
</body>
</html>
